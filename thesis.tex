\documentclass{article}
\usepackage{graphicx} % Required for inserting images
 \usepackage[tight]{subfigure}
 \usepackage{amssymb}
 \usepackage{amsmath}
 \usepackage{clrscode}
 \usepackage{hyperref}
 \usepackage{xcolor}
 
 \usepackage{natbib}
\setlength{\bibsep}{0.5pt}

\setlength{\oddsidemargin} {0 in}
\setlength{\textwidth} {6.5 in}
\setlength{\textheight} {8.5 in}
\setlength{\topmargin} {-0.5 in}
\def\h{\hspace{-.9pt}{\_}}
\newcommand{\reminder}[1]{ [[[ \marginpar{\mbox{$<==$}} #1 ]]] }
\newcommand{\eatreminders}[0]{\renewcommand{\reminder}[1]{}}

\title{Joss' Thesis}
\author{Joss Duff}
\date{\today}

\begin{document}

\maketitle

\reminder{ HFK: redirected bib to blockchain.bib.  Will explain more on our zoom.  Also note my ``reminder'' macro which gives us a way to add notes that not only stand out but also print (overleaf comments don't print).}

\section{Problem}
Blockchains are fundamentally pseudonymous and public: user identities are obfuscated behind addresses, but all activity between addresses is public by default.  In practice, entities are able to associate identities to addresses when on-ramping traditional funds to cryptocurrency and therefore track individuals' flows of funds on-chain.  In order for cryptocurrency to be practical for consumers, it must at the very least have the same level of privacy as traditional finance.  In traditional finance typically 2 entities know information about a user's funds; the user them self and the exchange that is custodian of the funds.  In blockchain settings, all entities can track user funds and activity.

\reminder{Joss: Do I need to make an argument for why privacy is important in this setting or can that be skipped?  Should I expand more on this?} 
\reminder{hfk: good for now.  For a broader audience worth pointing out with a real-life example: it is as if
a person paying with a debit card at a merchant reveals to that merchant full details on all past and future transactions on that account.}
\reminder{joss: There's a slew of real life online privacy horror stories that I could use as citations in a "privacy is safety" introduction.}

Privacy is a growing field in the blockchain space \cite{tornadocash, 7503, 6956581, ultraanon} but is suffering from malicious actors utilizing privacy to launder funds.  In an effort to reduce money laundering, regulatory bodies are pursuing legal action against developers of privacy protocols \cite{kuhn_samourai_2024,doj_tornado_cash_2023,bitcoin_fog_2021}.  This introduces the need for explicitly meeting regulatory compliance inside private on-chain applications.

Privacy and compliance classically oppose each other: privacy requires only the individual to know some information, and compliance requires that the individual meets a set of public criteria proposed by a government's regulatory body.  A user who meets some compliance criteria leaks privacy when they reveal a receipt of compliance to a counterparty because the counterparty now knows some properties of the compliant individual's information.

The goal is to maximize privacy while maintaining the ability to prove compliance.  Current research attempting to bridge privacy and compliance have proposed solutions with strict domain limitations, such as a new blockchain architecture or a new on-chain protocol.  We investigate a framework that allows for compliance in any blockchain domain and in any privacy protocol without compromising privacy provided by the protocol.  

\reminder{Joss: not actually *any* blockchain setting.  We won't be able to implement this onto blockchains without Turing complete smart contract languages.  Also it's unlikely that this will work for *any* privacy protocol but I'll come back to this statement when I have a better idea of what the blocking property is when I discover it.}

\reminder{Joss: "without compromising privacy provided by the protocol" is the goal.  I'll expand on the possibility of this later and will also revisit this statement.}

\section{Proposed Solution}
Zero Knowledge Proofs (ZKPs) are a natural avenue for proving compliance as they allow proving compliance without revealing user information.  Governments decide their criteria for regulatory compliance then express this criteria in a Zero Knowledge Domain Specific Language like Noir or Circom and publish the program to generate a proof of compliance.  They must also publish an address of the on-chain smart contract that can verify a ZKP of this compliance.  To prove compliance, users input their private data to the program and generate a ZKP.  Compliance can be verified at any time by inputting the ZKP to the verification contract.  

This framework will be used by privacy protocols to require users are compliant before executing smart contract logic.  For example, a developer could make a Tornado Cash clone that requires a United States regulatory compliance ZKP before depositing.  This check is implemented at the smart contract level and provides a guarantee as strong as the economic security of the blockchain the contract is deployed on that only US compliant entities can utilize the privacy from this Tornadocash clone.  Another Torando Cash clone can be deployed that only allows users who are compliant with China's regulation.

This fundamental idea raises multiple problems:
\begin{enumerate}
	\item Multiple and Changing Compliance Criteria
	\item Proof path
    \item Proof scaling
    \item properties available to prove
\end{enumerate}

\section{Multiple Compliance Criteria}
Each regulatory body of governments around the world will have different criteria of what "compliance" is in their government, and therefore will have different programs to generate ZKPs from.  Our framework needs to be able to have multiple proofs attached with a method to distinguish the proofs.  A user who has proved compliance with regulations A and B should be able to utilize an application that requires compliance with regulations A.  Unless compliance for A and B directly contradict each other.  In this case these two proofs shouldn't be able to be attached to the same subject in the first place.

\section{Updating Compliance Criteria}
Regulation is constantly updated and changed by governments.  Definitions of ``compliance" will undoubtedly change over time.  The framework needs to be able to handle up-datable compliance criteria.  A compliance update will start with the regulatory body publishing a new program and verifier contract for new ZKPs.  A new contract must be deployed because the new criteria of compliance might not be backward compatible with the previous criteria for that regulatory body.  If the same contract address was used then applications wouldn't have to update but it would result in unintended situations like non-compliant actors in the same anonymity set as compliant actors.  A simple example: compliance criteria starts of as a proof of non-membership in a set of sanctioned addresses.  This compliance is required in a Tornado Cash clone.  Users on-board to the Tornado Cash clone and benefit from eachother via the increasing anonymity set.  Then, the compliance criteria is updated to include more addresses in the list of sanctioned addresses.  A new verifier contract is not deployed so the Tornado Cash clone doesn't need to update.  One of the newly sanctioned addresses had previously sent funds into the Tornado Cash clone.  New users deposit into the TC clone and prove compliance on the new criteria.  However, now these users are mixing funds with sanctioned addresses and the sanctioned address is benefitting from the anonymity provided by the compliant users.  This means the newly compliant users are helping sanctioned addresses launder money.
\reminder{Joss: This is solved by requiring a compliance check on both entering and exiting of the pool.  The verifier address can stay the same}

\section{Trail of Proofs}
Compliant parties will require proof of compliance when interacting with them.  Generating these proofs (at least non-membership proofs) is well explored \cite{solomka2025zeroknowledge} \cite{tornadocashprimer}.  Proofs of compliance will have to be able to be chained back to the origin of the tokens you're using with the compliant party.  The origin could be a block reward or on-boarding from a centralized exchange.  The original tokens can change form or change hands but always have to be accompanied by a compliance proof.  If the tokens are sent through a mixer \cite{tornadocash} \cite{buterin2023blockchain} they will need a new compliance proof generated.  To prove compliance to a 3rd party, the owner of the tokens will need to provide the proof of compliance from before the mixer, and a proof of compliance generated after using the mixer.  This deanonymizes the owner of the tokens to the 3rd party, but the owner simply moves their tokens through another mixer to obfuscate their deanonymized address.  After this reanonymization, their next interaction with a compliant 3rd party will require 3 proofs, 1 proving compliant origin, and 1 for each use of a mixer.  The owner can choose to aggregate these proofs to only require 1 proof to prove compliance of a tokens history.
This model gets complex when different regulations are considered.  Each government and regulatory body will have independent and sometimes conflicting definitions of compliance.  Additionally, individual regulations might be given an addendum and require a versioning scheme.  Another problem is that this requires a strong network effect.  Each defi protocol or mixer must opt in to transferring or issuing proofs.  Compliance as a abstract property like consistency in DBs.  Compliance must be preserved through txns.  Make system for writing compliance constraints.  Could be in a programmatic lang or boolean logic (ex: SQL isn't Turing complete).  What is the minimum syntax needed for writing compliance proofs?  Limitations in the theory of computing, limitations in practicality, limitations in regulations (niche regulations, etc).  

Regulatory bodies would construct the proofs necessary to fit their definitions of compliance and deploy official proof verifier smart contracts.  Applications would opt in to consume and or produce these proofs.  When a user interacts with a compliant proof-consuming application, the user would also have to provide a proof of compliance with whichever regulations the application opted into.  The proofs are then validated on-chain during the smart contract execution.  If the proof fails to validate then the smart contract function reverts, preventing non-compliance on the smart contract level and making it impossible to circumvent regulation.  Question: when regulation changes, should the application have to undergo an upgrade?  

Regulatory bodies can express their logic in a novel DSL that compiles into a program that can be treated as composable units of compliance.  Take for example 2 independent regulatory bodies C1 and C2.  C2's compliance regulation is a superset of C1's compliance regulation.  In this situation, a compliance proof that is constructed for C2 should also prove compliance for C1.  Another example; C1 and C2's compliance is modeled through a set of properties Z1, Z2, and Z3.  C1 requires Z1 and Z2 to be true, and C2 requires Z2 and Z3 to be true.  A user whose funds are compliant for C1 should be able to generate a compliance proof for C2 by only generating a proof for Z3, as the proof for Z2 was already included in the C1 proof.  [[[Joss: I'm sure this is unreadable to anyone who doesn't already know what I'm trying to describe]]]
\reminder{HFK: the regulator's code can't compile directly to proofs since it states the criteria that an input set of transactions must satisfy.  Thus the code is the code over which a proof is generated with the transactional input kept private.}

Compliance proofs could be produced by the application or the user, if it involves private user data.  It's a pretty nice property that comes inherently from using ZK proofs.  The generation can happen in any setting.  

We'll examine these compliance proofs specifically in private settings, as that is the critical compliance area in blockchain currently, but the general framework could be applicable to any applications.  

\section{Drawbacks}

A problem is that this framework doesn't prevent a user using the privacy for non-compliant actions, it only proves that the user hasn't in the past used privacy for non-compliant actions.  For example, it can't prevent a user from sending mixed funds to make a purchase on the silk road.  This framework mainly protects developers of privacy protocols, as they have faced the largest punishments for enabling privacy \cite{kuhn_samourai_2024, doj_tornado_cash_2023,bitcoin_fog_2021}.  Secondarily, it protects users of privacy protocols who wish to remain fully compliant and only want privacy for security.

\section{Current Compliant Privacy Protocols}
As far as I know, the only two privacy protocols currently live that adhere to some compliance are Privacy Pools \cite{buterin2023blockchain} and Railgun \cite{railgun}.  Both only require a proof of innocence non-membership proof.  TODO: privacy pools and Railgun TVL as a proof of legitimacy and demand.  At the very least, this framework should make it trivial for other privacy protocols to integrate proofs of innocence.

\section{Constraint Domain Specific Language}
Regulatory bodies can express their compliance criteria in a novel Domain Specific Language (DSL) that complies down to a program to generate ZK proofs over.  The compliance will be expressed as a set of properties of an address over a period of time.  If this novel DSL is sufficiently advanced, it will be able to extract properties proven in proof A for the generation of proof B to save on proving costs. 

The regulatory body will publish a verifier contract for this program and publish both the address and program on a public registry to allow anyone to generate proofs of the program.

On first proof generation of an address, the beginning time T0 will be the transaction when the addresses first received funds and the ending time T1 will be the last transaction that interacted with the address.  When the address wishes to generate another proof of the same program, T0 will be the last time the address successfully verified a proof of this program and T1 will be the last transaction that interacted with the address.

Number of transactions from the address being proven for is the driving cost of proving time, not number of blocks since last proof generation.  A user with 1 transaction who last verified a proof 1000 blocks ago will have the same proving time as a user with 1 transaction who last verified a proof 5 blocks ago.  The ZK proof will take the address' transactions as inputs and verify the compliance constraints against each transaction.  The user can then use that proof to interact with an on-chain contract who requires compliance proof validation.

\section{Integration with mixers}
Mixers unlink the sender and receiver addresses on a token transfer, creating privacy for the user.  [TODO: example TC and Privacy pools].  Mixers can integrate with our proposed solution by requiring validation on entry and exit.  Validation on exit is required for the situation where an address becomes non-compliance after entering but before exiting as a result of a compliance update.  (This is basically the same approach as Privacy Pools).

"Exit" of a mixer occurs when a user supplies a note to the mixer that proves they know the secret that hashes to a leaf in the deposit Merkle tree.  When this occurs, the funds are sent from the mixer's balance to the address that the user wishes to withdraw too.  There is no way to prove association between any 2 deposit and withdraw transactions in a mixer without revealing a user's secret.  Say the user proved compliance on deposit to the mixer with account A and wishes to withdraw from the mixer with account B.  The user can supply their note during proof generation to prove membership of the deposit Merkle tree at a specific root as well as the block of that root.  Then the properties of the proof that was validated during deposit can be carried into the withdrawl proof, but other properties and proof history of the address is lost.

\reminder{joss: a problem I need to think about.  Unsure if it's our problem or a problem for DSL implementation.  

What if the user deposits into a mixer with some funds, then makes other transactions with other funds, then comes back and withdraws from the mixer.  How can the withdrawl compliance proof be context aware of the transactions the user made before withdrawing?

What if they withdraw to an address that already has a transaction history?
}

\section{Address genesis properties}
An address' first transaction is often receiving funds from an external source in order to pay gas costs for more transactions.  This external source can be a CEX, a block reward, or another user.  The problem is this "initialization" transaction of receiving funds from another address can't be distinguished from receiving funds from a mixer. 

When the initialization transaction comes from a CEX it can be accompanied by a proof of various KYC properties provided by the CEX similar to \cite{Xiong2025REGKYCSP}.  The CEX is able to assure lots of properties of an address that are otherwise unobtainable on-chain.  This is actually great for our solution because it incentivizes "washing" funds by sending them through CEXs, and CEXs hugely increase the breadth of properties available to regulatory bodies generating compliance constraints.  It also allows any compliant individual with a CEX account to re-establish their compliance properties if lost, for example, by going through a mixer.  A user simply would deposit funds into their CEX account and withdraw them.

\reminder{joss: How do smart contract wallets interact with this proposed solution?}

\bibliographystyle{abbrv}
\bibliography{blockchain}
\end{document}

