\documentclass{article}
\usepackage{graphicx} % Required for inserting images
 \usepackage[tight]{subfigure}
 \usepackage{amssymb}
 \usepackage{amsmath}
 \usepackage{clrscode3e}
 \usepackage{hyperref}
 \usepackage{xcolor}
 
 \usepackage{natbib}
\setlength{\bibsep}{0.5pt}

\setlength{\oddsidemargin} {0 in}
\setlength{\textwidth} {6.5 in}
\setlength{\textheight} {8.5 in}
\setlength{\topmargin} {-0.5 in}
\def\h{\hspace{-.9pt}{\_}}
\newcommand{\reminder}[1]{ [[[ \marginpar{\mbox{$<==$}} #1 ]]] }
\newcommand{\eatreminders}[0]{\renewcommand{\reminder}[1]{}}

\title{Joss' Thesis}
\author{Joss Duff}
\date{\today}

\begin{document}

\maketitle

\section{Abstract}
We present a framework for a composable privacy preserving compliance ecosystem.  In this framework, regulatory bodies publish definitions of compliance over any on-chain data: non-association checks, address history assertions, protocol interaction requirements, etc.  Applications select appropriate compliance definitions and require users to prove compliance on-chain before onboarding to the application.  This fulfills dual goals: regulators pushing for compliance and applications/users seeking precise compliance definitions, all without compromising privacy or the sanctity of the blockchain.  

We also lay out the fundamental building blocks of compliance definitions, \textit{constraints}, and discuss how future work can leverage them to create a novel Domain Specific Language that intelligently minimizes the computation necessary to prove compliance in this framework.

\reminder{Joss: I should weave in ``Proof of Innocence" somewhere into this paper.  That's a popular term in the industry and this framework can (and has by others) been described as a ``Fully abstracted Proof of Innocence".  Might help people understand.}

\section{Background and Definitions}
Background information on blockchains, privacy systems on blockchains, zero knowledge proofs, and our working definition of ``compliance".  People familiar with blockchain and ZK can skip this section.

\subsection{Blockchain Background}
Blockchains are fundamentally data storage systems with unique properties.  Most importantly, data stored on a blockchain (``on-chain") is \textit{immutable}.  This property is achieved by allowing \textit{anyone}\footnote{There is a small class of ``permissioned" blockchains that only allow whitelisted individuals to participate in consensus and validation.} around the world to participate in consensus and validation of the blockchain's state by running a node.  

The first blockchain, Bitcoin, was created in 2008 and proposed a trustless ledger of transaction histories \cite{Bitcoin}.  Ethereum was created in 2013 and improved on Bitcoin by allowing trustless execution of Turing-complete logic on-chain, referred to as ``smart contracts" \cite{Buterin13}.  This allowed for more complex applications like marketplaces and lending platforms to exist in a decentralized, permissionless, and immutable setting. 

Every transaction on a blockchain has a nonstatic monetary cost paid to the block producing node as an incentive to include the transaction in the next write.  Some blockchains with smart contract support, like Ethereum, include an additional transaction cost driven by the complexity of the smart contract logic being executed.  

Users on blockchains are represented by a public key address.  The user signs messages and transactions with the associated private key.  Users can have multiple public key addresses.  It is impossible to reveal who is associated with a public key until the user reveals their identity.

A centralized exchange (``CEX") is a company that allows users to trade traditional currency for cryptocurrency.  They often require the user to connect their bank account and supply regulatory documentation such as identification cards and proof of residency.  This is a common method for acquiring cryptocurrency.  CEXs are ``custodial" which means they control the address (they know the private key) that owns the cryptocurrency on-chain and allow the user to trade or transfer it.  They also allow users to send their cryptocurrency from the CEX account to the users' own on-chain address.

\subsection{Privacy in the Blockchain Setting}
All data on blockchains are public by default unless the chain supports special privacy features, for example, Aztec Network supports private state.  There are also some enterprise permissioned blockchains that restrict visibility levels.  However, the vast majority of chains are public by default, including Ethereum and Bitcoin.

For public blockchains, every user's entire transaction history is exposed to the world.  This is obviously undesirable for consumers.  Most people don't want their purchase or subscription history visible to the entire world.  Many applications and protocols exist to provide users varying degrees of privacy.
\reminder{Joss: Should I replace the term ``mixer" with ``privacy pool" throughout this paper?  ``Privacy pool" is a lot less scary and criminal sounding than ``mixer", but it is easily confused with ``Privacy Pools", a mixer that came out last year as a result of the paper \cite{buterin2023blockchain}}

Blockchain privacy protocols fall into two broad categories: 
\begin{itemize}
    \item App layer privacy: Applications on top of existing blockchains.
    \item Base layer privacy: Entirely new blockchain architectures with privacy as a core identity.
\end{itemize}

\paragraph{Application layer privacy}
Tornado Cash was the first permissionless transaction mixer and innovated by encapsulating the mixing logic in a smart contract~\cite{tornadocash}.  The black-hat group Lazarus user Torando Cash to launder stolen funds and the Tornado Cash developers were put on trial~\cite{doj_tornado_cash_2023}.  Railgun is a transaction mixer that focuses on compliance~\cite{railgun}.  Privacy Pools is a recent transaction mixer that also focuses on compliance with Association Sets~\cite{buterin2023blockchain}.  Ultra-Anon is an experimental privacy token that has the property of \textit{plausible deniability}: it isn't revealed if users utilized privacy~\cite{ultraanon}.

Apps: Privacy Pools, Tornadocash, Railgun, Ultra Anon, zkBob, Kohaku (wallet), stealth addresses, bank of jubjub
Base layer privacy: Aztec, Miden, Zcash, Monero, 7503, Aleo, Penumbra, the stablecoin L1s, secret network, Iron fish?, neptune cash

\reminder{HFK: ultimately, this can be a place to cite every existing privacy
technology that you want to appear in the references.  This is a standard way of ensuring that readers/reviewers do not think you are unaware of certain prior work.  That's part of the reason I moved Aztec up from the footnote.  You can list more tech here.}

\subsubsection{Anonymity Set}
The anonymity of an address is a measurement of how indistinguishable the address is within a set of addresses; the anonymity set~\cite{anonterminology,anonset}.  For mixer applications on blockchains, any address that has deposited can withdraw, but it is never revealed which depositing addresses have an associated withdrawal.  Therefore, the anonymity set of any given withdrawal from the mixer is the set of all addresses that have deposited in the mixer.  This is oversimplified, and in practice anonymity sets can be greatly reduced with chain analysis \cite{zcashanalysis,moneroanalysis}.  Anonymity here is referring to the obfuscation of the link between a depositing and withdrawing address.

\subsection{Zero Knowledge Proof}
Zero Knowledge (ZK) proofs are a cryptographic technique that allows a party to prove claims about a computation without revealing the entire computation.  

The ``claim'' proven by a ZK proof is expressed as a type of program that is often called a ``\textit{circuit}''.  Mathematically, it suffices to think of it as a function $f(x, w) \rightarrow \{\text{True}, \text{False}\}$, where $x$ is the public input, $w$ is the private input, and $f(\cdot)$ is the function being computed. A ZK proof proves that, for a given $x$ known both by the prover and the verifier, the prover knows a $w$ such that $f(x, w)$ returns $\text{True}$~\cite{buterin2023blockchain}.  \reminder{Joss: this paragraph, up to here, is copied from one of Vitalik's papers.  I really liked his explanation of a circuit.  I cited it, but should I also put this section in quotes?} ZK proofs have the property of \textbf{Zero-knowledge}: proving the claim doesn't reveal the private input.

SNARKs are a specific type of ZK proof that has the unique property of \textbf{Succinctness}: The proof size doesn't grow with the size of the computation, and the proof can be verified very quickly relative to the computation~\cite{Petkus}.

A bottleneck with some SNARK schemes, such as Groth16, are that they rely on a \textit{trusted setup}: a time intensive ceremony involving multiple participants.  A trusted setup needs to be performed once per circuit~\cite{lavin2024surveyapplicationszeroknowledgeproofs}.

A type of SNARK proofs, PLONK, removes this bottleneck by efficiently allowing trusted setups to be re-used across circuits.  With PLONK proofs, it is not necessary to initiate a new trusted setup for every new circuit~\cite{Gabizon2019PLONKPO}.

\subsection{Compliance}
Compliance is referred to as the goals and properties of a system to attempt to adhere to a law or policy.  Compliance isn't immunity from prosecution, it is a best effort to prove legality of actions.  For example, US companies have systems in place to prevent money laundering in order to be compliant with the US Bank Secrecy Act (BSA) - also referred to as Anti-Money Laundering (AML) \cite{usc31_5318h}.  A typical effort to comply with AML in the blockchain space is blocking addresses associated with sanctioned individuals from interacting with a protocol.  

A goal of this framework is to be flexible enough to accommodate compliance definitions over all aspects of a transaction: the payer, the payee, the content of the transaction, and even the actors' transaction histories.  Flexibility results in the ability to express any definition of compliance.

\section{Problem} 
Blockchains are fundamentally pseudonymous and public: user identities are obfuscated behind addresses, but all activity between addresses is public by default.  In practice, entities are able to associate identities to addresses when on-ramping traditional funds to cryptocurrency and therefore track individuals' flows of funds on-chain.  In order for cryptocurrency to be practical for consumers, it must at the very least have the same level of privacy as traditional finance.  In traditional finance typically 2 entities know information about a user's funds; the user them self and the exchange that is custodian of the funds.  In blockchain settings, all entities can track user funds and activity.  Neither consumers nor corporations will want their entire trading, purchasing, or subscription histories publicly available.

Privacy is a growing field in the blockchain space \cite{tornadocash, 7503, 6956581, ultraanon}, but is plagued by malicious actors using privacy to launder funds.  In an effort to reduce money laundering, regulatory bodies are pursuing legal action against developers of privacy protocols \cite{kuhn_samourai_2024,doj_tornado_cash_2023,bitcoin_fog_2021}.  This introduces the need to explicitly meet regulatory compliance inside private on-chain applications.

Privacy and compliance classically oppose each other: privacy requires only the individual to know some information, and compliance requires that the individual meets a set of public criteria proposed by a government's regulatory body.  A user who meets some compliance definition loses anonymity when they reveal a receipt of compliance to a counterparty because the counterparty now knows some properties of the user's information.

The goal is to maximize privacy while maintaining the ability to prove compliance.  Current research attempting to bridge privacy and compliance have proposed solutions with strict domain limitations such as a new blockchain architecture, specific on-chain protocols, or privacy violations.  We investigate a framework that allows for compliance in any blockchain smart contract environment and in any privacy protocol without compromising privacy provided by the protocol.

\subsection{Industry Interest}
In a 2025 survey, 300 major financial firms were asked what factors keep them from becoming more involved in blockchain technology. In this multiple choice question, 52\% cited lack of regulatory certainty and 50\% cited lack of privacy as factors~\cite{paradigm2025tradfi}.  Resolving either of these concerns would result in a large amount of capital being allocated to blockchain applications.  

\reminder{HFK: Here we can go beyond financial stuff. Supply chain is a good example here. It can help a B2B supply chain run on a public L1 underpinning.  Also within a permissioned system, it can reduce the degree of central control by the permissioning agent.  The concept could fit in the Oracle framework -- or at least Mark Rakhmilevich saw some merit to it. }

\section{Privacy Preserving Compliance}
\label{sec:privacy-preserving-compliance}
It is necessary to introduce a stricter definition of ``Privacy Preserving Compliance".  A compliance system is privacy preserving if it has \textbf{verifiable compliance}, \textbf{no deanonymization}, \textbf{secret inputs},  and \textbf{inherits the maximum theoretical anonymity} of its adjacent privacy system.  Our framework maintains these properties and therefore meets the criteria of a ``Privacy Preserving Compliance" system.  The definition of Privacy Preserving Compliance aims to provide a path for compliance without compromising the benefits of having a privacy system on-chain.

\textbf{No deanonymization:}  ``deanonymization" refers to revealing private information about an address like balances or transaction history.  No entity should have the privilege of deanonymizing user data in an on-chain privacy system\footnote{Caveat: A user can always choose to reveal their own private transaction history.  There is no way to prevent this and it is acceptable because the user is initiating their own deanonymization.  ``No deanonymization" refers to third-party deanonymization.}.  

The existence of the ability to deanonymize users is a risk vector to users and compromises trustlessness.  Individuals with access to private information can and will abuse it.  For example, the case of Twitter employees selling user personal data to Saudi Arabia \cite{newman2019twitter, collier2022twitter}, or US telecom providers illegally selling user data \cite{daws2024fcc}.  Additionally, any centralized collection of user data can be hacked.  In 2024, data that US telecommunication companies were legally required to collect was hacked \cite{sakellariadis2024china}.  In 2025, personal data held by the Ukranian government was hacked by Russia \cite{post2025ukraine}.  In 2022, 23 terabytes of personal information on 1 billion Chinese residents was leaked from a police database and sold \cite{wikipedia2025shanghai}.

An on-chain privacy system with deanonymization does not benefit from the properties of being on-chain in the first place.  A privacy system where a 3rd party also knows secret user data is as ``private" as a traditional exchange or bank.  In order for a on-chain privacy system to provide unique value to users, it must not allow for deanonymization.

\textbf{Verifiable compliance:} Compliance criteria should be publicly viewable and a user's compliance status should be verifiable.  For example, a user's compliance status should not be determined behind a third-party API as this runs the risk of the third-party not properly enforcing the compliance definition, introducing risk to all parties involved.  This trust assumption could potentially be mitigated with techniques such as Trusted Execution Environments (TEEs) that verifies that a third-party correctly executed some computation \cite{haventee}.  The approach in this framework is to publicly publish compliance definitions and have users generate their own ZK proofs that can be cryptographically verified.

\textbf{Secret inputs:} Allow for arguments in the compliance function that are only known to the subject.  This is trivial in most solutions that utilize ZK proofs for compliance verification, as ZK proofs inherently allow secret inputs. \reminder{Joss: might not be a hard requirement for PPC but I'll have to think about it.  It's a nice property of our framework however.}

\textbf{Maximum theoretical anonymity of compliant privacy:}  There exists a theoretical maximum anonymity set for any privacy system that aims to be compliant.  A privacy system has anonymity set $P$ and a compliance definition has $N$ addresses that meet the criteria.  If this compliance definition is enforced for entry and existence in the privacy system's anonymity set, then any address that participates has a maximum anonymity set of $min(P, N)$.  This is because the user is most identifiable in the smallest set it is a member of.  Our framework provides this maximum theoretical anonymity.

\section{Related Work and Attempted Solutions}
\begin{itemize}
    \item One sentence or two on each paper / system that attempts to solve this and the properties they're lacking.
    \item Put it into a table comparing them against our framework
    \item Its easy to compare other papers that propose solutions but I'm unsure on how to compare some of the applications to us as they're just single applications and we're proposing an entire framework.
\end{itemize}
As far as I know, the only two privacy protocols currently live that adhere to some compliance are Privacy Pools \cite{buterin2023blockchain} and Railgun \cite{railgun}.  Both only require a proof of innocence non-membership proof.  TODO: privacy pools and Railgun TVL as a proof of legitimacy and demand.  At the very least, this framework should make it trivial for other privacy protocols to integrate proofs of innocence.  Panther protocol, Aleo, the stablecoin L1s, Iron Fish
\reminder{Joss: TODO: A tree structure for other privacy / compliance applications.  Like in the paper Alex presented for reading class.}


\section{Proposed Solution}
We propose a framework that allows for a composable privacy preserving compliance ecosystem.  In this framework, regulators or compliance providers construct definitions of compliance over on-chain activity and publish this definition.  On-chain applications identify which of these definitions best fit their compliance needs and make a smart contract requirement that users meet the definition.  To use these applications, users must first supply a zkSNARK proof that their address meets the definitions of compliance.  

Each published compliance definition can be used by any number of applications, and applications can require multiple compliance definitions for their users.  Compliance definitions can be published by anyone, but applications will be careful to select definitions published by reputable sources like regulatory bodies or blockchain intelligence companies like Chainalysis or TRM Labs. \reminder{Joss: cite these two}.

The logical building blocks of the compliance definition over on-chain data are referred to as constraints, and discussed more in Section~\ref{sec:constraints}.

\subsection{End-to-end interaction example}
This is a simple end-to-end interaction example of this framework for a user Alice interacting with a protocol that requires US compliance.
\begin{enumerate}
    \item A regulator creates a definition that aims to comply with US regulation and makes this definition public.
    \item A US based protocol adds a smart contract requirement that users supply a ZK proof of the above definition.
    \item Alice generates a ZK proof of the above definition off-chain.
    \item Alice supplies the proof as an argument in her first interaction with the protocol.
    \item Alice's proof is verified on-chain.
    \item Protocol continues its regular smart contract logic with the assurance that Alice is compliant in the US, but knowing nothing else about Alice.
\end{enumerate}
This is a small example that illustrates the overall flow of user interaction.  Further sections will detail composing compliance definitions, optimizations of compliance logic, smart proof re-usage, and integration with mixers.

\subsection{Benefits}
In addition to meeting the definition of Privacy Preserving Compliance~\ref{sec:privacy-preserving-compliance} this framework is \textbf{chain agnostic}: it can be applied to any chain with Turning complete smart contracts and the ability to efficiently verify ZK proofs.  Also, it has the properties of composability and constant cost compliance.

\textbf{Composability:} The same definition of compliance can be used by any number of protocols, a user can generate proofs for any published definitions of compliance, and proofs for multiple compliance definitions can be required by a protocol.  Compliance definitions can be fine grained instead of wide umbrella definitions.  For example, instead of having a single definition that encompasses all US rules and regulations, there can be a definition for US consumer compliance and a definition for US corporation compliance.
\reminder{Joss: TODO: diagram advertising composability. }

\textbf{Constant cost compliance:} The cost to verify compliance proof on-chain does not grow with the size of the compliance definition.  This is inherited from using zkSNARKs as compliance proofs.  The circuit can be very computationally intensive and have pages of criteria, but it will still cost the same amount as a circuit with a single operation. 

\subsection{Constraints}
\label{sec:constraints}
Although regulations vary globally and over time, they often rely on similar logical primitives: checking membership in lists, comparing values against thresholds, or verifying historical patterns. We built our framework to exploit this similarity by decomposing compliance definitions into reusable logic that we refer to as \textbf{constraints}.  This compositional structure allows for complex requirements to be expressed as combinations of atomic constraints.

A \textbf{constraint} is a boolean predicate that evaluates blockchain state and auxiliary inputs. A constraint $C$ is expressed in the form:

$$C = (\text{subject } \phi \text{ parameter, at chain state})$$

where:
\begin{itemize}
    \item \textbf{Subject} ($s \in \mathcal{S}$): the on-chain entity or data being evaluated.  Subjects are the result of any computable function over a blockchain state that can be evaluated deterministically. Example subjects include:
    \begin{itemize}
        \item Sender of a transaction: $\text{sender}(\text{txn})$
        \item Recipient of a transaction: $\text{recipient}(\text{txn})$
        \item Transaction sequences: $\{\text{txn}_1, \ldots, \text{txn}_n\}$
        \item Account balance: $\text{balance}(\text{addr})$
        \item Result of a contract call: $\text{result}(\text{contract fn})$
        \item Transaction payload: $\text{payload}(\text{txn})$
    \end{itemize}
    
    \item \textbf{Operation} ($\phi$): the logical or comparison operation applied between all subjects and parameters. Common operations include:
    $$\phi \in \{=, \neq, <, \leq, >, \geq, \in, \notin, \ldots\}$$
    
    \item \textbf{Parameter} ($p \in \mathcal{P}$): the value or set against which the subject is evaluated, containing:
    \begin{itemize}
        \item Public parameters $p_{\text{pub}}$ provided by the compliance author (e.g., sanction lists, required values)
        \item Private inputs $p_{\text{priv}}$ provided by the user (e.g., mixer secret, identifying information)
    \end{itemize}

    \item \textbf{Chain State} ($i \in \mathcal{I}$): the point in time or time range over which the subject is evaluated against the blockchain state. Examples include:
    \begin{itemize}
        \item Current block: $B_{\text{current}}$
        \item Historical block: $B_h$ for $h < \text{current}$
        \item Block range: $[B_i, B_j]$
        \item Unix timestamp
    \end{itemize}
\end{itemize}

The constraint function has the signature:

$$C: \mathcal{S} \times \mathcal{P} \times \mathcal{I} \rightarrow \{\text{true}, \text{false}\}$$

with $C(s, p, i) = \text{true} \iff s \,\phi\, p$ holds at chain state $i$.

\subsubsection{Example constraint}
Sanction list checks are a popular compliance measure in the blockchain space~\cite{solomka2025zeroknowledge, tornadocashprimer}.  The constraint ``Sender of this transaction is not on sanction list $A$'' can be decomposed as follows:

\begin{itemize}
    \item \textbf{Subject}: $\text{sender}(\text{txn})$ --- the address that initiated the transaction
    \item \textbf{Operation}: $\notin$ --- does not exist in
    \item \textbf{Parameter}: $A$ --- the sanction list (a public parameter provided by the regulator)
    \item \textbf{Chain state}: $B_{\text{current}}$ --- evaluated at the current block
\end{itemize}

The constraint evaluates to \textbf{true} if and only if the subject (sender of the transaction) does not exist in the parameter (sanction list).  Formally expressed as:

$$C_{\text{sanction}} = (\text{sender}(\text{txn}) \notin A, B_{\text{current}})$$

\subsubsection{Example: shared constraints}
When multiple compliance definitions require the same constraint, that constraint can be proved once and applied to multiple definitions.  For example, an application wishes to be compliant with two regulatory bodies.  These regulatory bodies have published compliance definitions $R_1$ and $R_2$, respectively.  The application requires users to supply a valid proof of $R_1$ and $R_2$.  $R_1$ and $R_2$ are composed of simple constraints:

$$R_1 = C_1 \land C_2$$
$$R_2 = C_1$$

A user of the application only needs to compute a proof for $R_1$ because it's constraints are a super-set of the constraints used in $R_2$: proving $R_1$ also proves $R_2$.

\paragraph{Another Example}
An application requires $R_1$ and $R_2$:
$$R_1 = C_1 \land C_2$$
$$R_2 = C_2 \land C_3$$

Constructing a proof that validates for both regulations only requires generating a proof for three constraints, as $C_2$ is included in both definitions.  $C_2$ is computed once and applied to both $R_1$ and $R_2$.

\subsubsection{Compliance definition} A compliance definition is a combination of constraints with boolean operators and a time parameter during which the definition is valid.  The time parameter is necessary to account for regulations changing over time and to allow for regulations to be published before they go into effect. Given constraints $C_1, \ldots, C_k$, a compliance definition $R$ is defined as:
$$R = (C_1 \land C_2 \land \cdots \land C_k, [t_{\text{start}}, t_{\text{end}}])$$

where $t_{\text{start}}$ and $t_{\text{end}}$ denote the block heights or timestamps defining the validity period of the rule. The rule $R$ is considered active if and only if the evaluation occurs within this temporal window:
$$\text{active}(R, t) = \begin{cases}
\text{true} & \text{if } t_{\text{start}} \leq t \leq t_{\text{end}} \\
\text{false} & \text{otherwise}
\end{cases}$$

Alternatively, open-ended validity can be expressed with $t_{\text{end}} = \infty$ for rules with no expiration.  For brevity in this paper, the time parameter is omitted for compliance definitions and can be assumed to be valid for the current time.



\subsubsection{Address genesis constraints}
An address' first transaction is often receiving funds from an external source.  This external source can be a CEX, a block reward, another user, or a smart contract.  The CEX checks properties of an address that are otherwise unobtainable on-chain.  For example, many CEXs require users are KYC'd, are over 18, and reside in a specific country.  This is a great benefit to the framework because it hugely increases the breadth of properties available to regulatory bodies generating compliance constraints.  When an addresses' genesis transaction comes from a CEX it can be accompanied by a proof of various Know Your Customer (KYC) properties provided by the CEX similar to \cite{Xiong2025REGKYCSP}.  It also allows any compliant individual with a CEX account to re-establish their compliance properties if lost, for example, by going through a mixer.  A user simply would deposit funds into their CEX account and withdraw them to a new address.

\reminder{HFK: not sure about that last point. While the CEX takes fiat currency without checking the funds' provenance, the user still has a history with a mixer.  There would need to be an extra step of taking mixer funds in cash or other untracked medium into an account owned by a new entity not having a mixer in its history.  The larger point here is that while we are tracking and proving every transaction, most tradfi transactions flow along unchecked.  There is a possibly scary potential here of building a more regulated environment than we have now. That is not a framework issue, but is an issue of best practices for regulatory use of our framework -- allowing current ``safe harbor'' practices to carry over to permit freedom despite the risks.}

\reminder{Joss: TODO: ZK passport would be a great example requirement for an implementation.  A constraint that requires a ZK passport proof}
\reminder{HFK: yes, and that is a reminder that in our writing we need to be careful to distinguish between what the framework {\it enables} and what the framework itself is.  Important that the reader not think our example constraints are required constraints.}

\subsection{Integration with commitment tree privacy mixers}
Mixers unlink the sender and receiver addresses on a token transfer, creating privacy for the user.  Compliance proofs can be maintained through mixers without costing privacy when utilizing this framework.  ``Exit" of a mixer occurs when a user supplies a note to the mixer that proves they know a secret that hashes to a leaf in the deposit Merkle tree.  When this occurs, the funds are sent from the mixer's balance to the address that the user wishes to withdraw to.  There is no way to prove association between any two deposit and withdraw transactions in a mixer without the user revealing their secret.

Similar to ``Derecho: Privacy Pools with Proof-Carrying Disclosures"~\cite{10.1145/3658644.3670270}, the compliance properties required to enter the mixer can be transferred to the withdrawing address by proving the withdrawing address knows the secret of a leaf in the commitment tree, therefore proving that they have access to an account that met the compliance requirements to deposit into the mixer.  Then an additional proof needs to be made to assure that the withdrawing account hasn't previously violated compliance constraints.  Only the constraints required for depositing to the mixer can be carried to the withdrawing address.

\textbf{Example}: Alice signs up to Coinbase and provides required KYC documents.  Alice then receives funds at her on-chain address from a known Coinbase address.  Alice can trivially prove that address received funds from Coinbase.  Alice does not want her entire transaction history to be public so she deposits some funds in a mixer that has integrated this framework and requires a proof of compliance with the definition

The constraint ``The sender of this transaction's first transaction was from a set of addresses $A$'' is formally expressed as:

$$C_{\text{origin}} = \left(\text{sender}(\text{first-txn}(\text{sender}(\text{txn}))) \in A \text{ at } [B_0, B_{\text{current}}]\right)$$

where $\text{first-txn}(\text{addr})$ returns the earliest transaction where $\text{addr}$ appears as the recipient.
\reminder{Joss: The syntax being this hard to read reveals a faulty formula for constraints.  The sender should always be the main subject, and it shouldn't have to reference the entire chain state.  I'll take another look at this later}

Alice later withdraws her funds from the mixer to a freshly generated address with no transaction history.  Even though this address never received funds from Coinbase, Alice is able to supply her commitment tree secret into a circuit to prove that she is transferring from an address that successfully proved $C_1$, and therefore can prove $C_1$ when interacting with protocols with her new address.

\subsection{Multiple compliance criteria}
Each regulatory body of governments around the world will have different criteria of what ``compliance" is in their government, and therefore will have different programs to generate ZKPs from.  Our framework allows for multiple proofs to be required by protocols.  A user who has proved compliance $A$ and $B$ is able to utilize an application that requires a proof of $A$, $B$, or both $A$ and $B$.  Unless $A$ and $B$ directly contradict each other, in which case a correct proof cannot be generated.

\subsection{Updating Compliance Criteria}
Laws and regulations are constantly updated and by governments.  Definitions of ``compliance" change over time.  The framework allows updates to compliance criteria.  The owning address of a compliance verifier contract may push updates to the contract when new compliance circuits are constructed.  No action needs to be taken by protocols who require compliance as the contract address doesn't change, but users who previously generated a proof against the old circuit but have not used it yet will have to regenerate their proof.

\section{Prototype}
This framework is applicable to any blockchain with a Turing-complete smart contract language and constraints can be written in any syntax as long as they are representable in a ZK circuit.  For our initial prototype of this framework, constraints are expressed in the Noir ZK DSL \cite{AztecNoir22} and the application integrating this framework will use the Ethereum Virtual Machine (EVM) expressed through the Solidity smart contract DSL.  Noir was chosen because it provides high-level language semantics for writing ZK circuits.  The EVM and Solidity were chosen because they have a large and polished ecosystem of smart contract tools.

\subsection{Prototype constraints}
The prototype constraints demonstrate the flexibility and expressiveness of our constraint formalism. Each constraint follows the structure $C: \mathcal{S} \times \mathcal{P} \times \mathcal{I} \rightarrow \{\text{true}, \text{false}\}$ where $C(s, p, i) = \text{true} \iff s \,\phi\, p$ holds at chain state $i$. These constraints were chosen to highlight the integration of the framework with common compliance practices.

\bigskip
\noindent\textbf{Non-Membership Constraint (\texttt{NON-MEM})}: Proves that an address is not in a given set. For example, proving an address is not on a list of US sanctioned addresses.
$$C_{\text{non-mem}} = (\text{sender}(\text{txn}) \notin p_{\text{sanctioned}}, B_{\text{current}})$$
where $p_{\text{sanctioned}}$ is the public parameter containing the sanction list.

\bigskip
\noindent\textbf{Membership Constraint (\texttt{MEM})}: Proves that an address is in a given set. For example, proving an address is on an allow-list.
$$C_{\text{mem}} = (\text{sender}(\text{txn}) \in p_{\text{allowlist}}, B_{\text{current}})$$
where $p_{\text{allowlist}}$ is the public parameter containing the allowed addresses.

\bigskip
\noindent\textbf{Protocol Interaction Constraint (\texttt{INTERACT})}: Proves that at some point in their transaction history, an address interacted with a specific protocol.
$$C_{\text{interact}} = (\exists \text{txn} \in \text{history}(\text{sender}(\text{txn})) : \text{recipient}(\text{txn}) = p_{\text{protocol}}, [B_0, B_{\text{current}}])$$
where $p_{\text{protocol}}$ is the address of the required protocol.

\bigskip
\noindent\textbf{Protocol Avoidance Constraint (\texttt{AVOID})}: Proves that throughout their transaction history, an address never interacted with a specific protocol.
$$C_{\text{avoid}} = (\forall \text{txn} \in \text{history}(\text{sender}(\text{txn})) : \text{recipient}(\text{txn}) \neq p_{\text{protocol}}, [B_0, B_{\text{current}}])$$
where $p_{\text{protocol}}$ is the address of the prohibited protocol.

\bigskip
\noindent\textbf{Age Constraint (\texttt{AGE})}: Requires that an address be at least a certain age. For example, require all addresses' first transactions were at least 6 months ago as an effort to reduce sybil addresses.
$$C_{\text{age}} = (B_{\text{current}} - \text{first-txn}(\text{sender}(\text{txn})).block \geq p_{\text{min-age}}, B_{\text{current}})$$
where $B_{\text{first}}(\text{addr})$ returns the block height of the address's first transaction and $p_{\text{min-age}}$ is the minimum required age in blocks.

\bigskip
\noindent\textbf{Funding Source Constraint (\texttt{FUND-SRC})}: Proves that the initial funding for an address was from a set of addresses. For example, ensure the individual went through Coinbase's KYC protocol by requiring they received funds from a Coinbase address.
$$C_{\text{fund-src}} = (\text{sender}(\text{first-txn}(\text{sender}(\text{txn}))) \in p_{\text{sources}}, [B_0, B_{\text{current}}])$$
where $\text{first-txn}(\text{addr})$ returns the first transaction received by the address and $p_{\text{sources}}$ is the set of approved funding sources.

\bigskip
\noindent\textbf{Structuring Constraint (\texttt{STRUCTURE})}: Specific example of US Bank Secrecy Act non-structuring requirement. Proves a user has not sent multiple transactions totaling over \$10,000 within a window of time to the same recipient.
$$C_{\text{structure}} = (\forall r \in \text{recipients}, \forall [B_i, B_j] \subseteq [B_0, B_{\text{current}}] \text{ where } (B_j - B_i) \leq p_{\text{window}} :$$
$$\sum_{\text{txn} \to r \text{ in } [B_i, B_j]} \text{amount}(\text{txn}) < p_{\text{threshold}}, [B_0, B_{\text{current}}])$$
where $p_{\text{window}}$ is the time window (e.g., 24 hours in blocks) and $p_{\text{threshold}} = 10000$ USD equivalent.

\subsection{Integrating applications}
In this prototype, applications integrate this framework by requiring proofs of compliance at specified entrypoint functions.  Applications choose compliance definitions based on the applications regulatory goals.  

For prototype purposes, compliance definitions aren't implemented as composable constraints, and are instead written as custom circuits.  Constraints are still listed to show the logical definition.

Each compliance definition $R$ is compiled as a ZK circuit using Noir and then published and maintained in a separate verifier Solidity contract, allowing the integrating application to reference compliance logic without implementing it directly.  

\subsubsection{Example: Compliant Stablecoin}
The author of this stablecoin contract is, for example, a US based company and wishes to only allow users who are not on a list of US sanctioned addresses $p_{\text{sanctioned}}$ to interact with this stablecoin. 

The compliance definition requires both sender and recipient to satisfy the non-membership constraint:
$$R_{\text{stablecoin}} = C_{\text{non-mem}}(\text{sender}) \land C_{\text{non-mem}}(\text{recipient})$$
where both constraints evaluate against the same sanction list $p_{\text{sanctioned}}$.

\bigskip
\textbf{Compliance Verifier Contract:}
\begin{codebox}
\Procname{Contract: $R_{\text{stablecoin}}\text{Verifier}$}
\li \Comment State: $\id{sanctionedAddresses}$ (set of sanctioned addresses)
\li
\li $\proc{VerifyCompliance}(\id{sender}, \id{recipient}, \id{proof})$
\li \>\Comment Construct public inputs for verification
\li \>$\id{publicInputs} \gets \proc{FormatPublicInputs}(\id{sender}, \id{recipient}, \id{sanctionedAddresses})$
\li \>
\li \>\Comment Verify both parties satisfy NON-MEM constraint
\li \>\kw{assert} $\proc{Verify}(\id{proof}, \id{publicInputs})$
\li \>
\li \>\Return \const{true}
\end{codebox}

\bigskip
\textbf{Stablecoin Contract:}
\begin{codebox}
\Procname{Contract: CompliantStablecoin}
\li \Comment State: 
\li \>\>$\id{balance}$ (mapping from address to uint)
\li \>\>$\id{verifierContract}$ (address of $R_{\text{stablecoin}}\text{Verifier}$)
\li
\li $\proc{Transfer}(\id{recipient}, \id{amount}, \id{proof})$
\li \>$\id{sender} \gets \id{tx.origin}$
\li \>
\li \>\Comment Verify compliance through external verifier contract
\li \>\kw{assert} $\id{verifierContract}.\proc{VerifyCompliance}(\id{sender}, \id{recipient}, \id{proof})$
\li \>
\li \>\Comment Execute transfer
\li \>\kw{assert} $\id{balance}[\id{sender}] \geq \id{amount}$
\li \>$\id{balance}[\id{sender}] \gets \id{balance}[\id{sender}] - \id{amount}$
\li \>$\id{balance}[\id{recipient}] \gets \id{balance}[\id{recipient}] + \id{amount}$
\li \>
\li \>\Return \const{true}
\end{codebox}

This architecture demonstrates the composability of the framework: the compliance definition $R_{\text{stablecoin}}$ is maintained independently from the stablecoin logic, allowing the sanction list to be updated without modifying the stablecoin contract itself.

\subsubsection{Airdrop}
An example showing that this framework can do more than just regulatory compliance. An airdrop distribution might require:
\begin{enumerate}
    \item Interaction with a specific protocol (\texttt{INTERACT})
    \item Membership in an allowlist (\texttt{MEM})
    \item Account age requirement (\texttt{AGE})
\end{enumerate}

The compliance definition is:
$$R_{\text{airdrop}} = C_{\text{interact}} \land C_{\text{mem}} \land C_{\text{age}}$$

\subsubsection{Proof carrying privacy pool}

This is a complete implementation demonstrating that you can use this framework to be both compliant and private, similar to Derecho: Privacy Pools with Proof-Carrying Disclosures~\cite{10.1145/3658644.3670270}.

This demonstrates the framework's ability to provide both compliance and privacy. The privacy pool requires compliance constraints on entry, but allows users to carry these proofs through the mixer to their withdrawal address.

\textbf{Entry constraints:} When depositing into the pool, users must prove:
$$R_{\text{entry}} = C_{\text{non-mem}} \land C_{\text{fund-src}}$$

\section{Benchmarks}
\begin{itemize}
    \item Benchmark graphs with reasoning for each test and implementation code link
    \item Discussion on which patten will be most heavily used and what acceptable performance is
    \item Prove non-membership of the set of 0 addresses
    \item Prove membership of the set of all addresses
    \item Prove address genesis property (from coinbase, US citizen, etc)
    \item Prove they didn't structure historic transactions over 10k
    \item Prove over large transaction histories
    \item more...
\end{itemize}

\section{Future Work}

\subsection{Constraint Domain Specific Language}
To transform written law into a zkSNARK there needs to be a human readable intermediary syntax.  The constraint system introduced in \ref{sec:constraints} can be extended into a novel DSL used by regulatory bodies to define compliance.  If this novel DSL is sufficiently advanced, it will be able to extract constraints proven in proof A for the generation of proof B to save on proving costs.

This constraint language compiles either directly to ZK circuits or to inputs for proof composition, enabling efficient on-chain verification of complex compliance requirements.

It is often the case that some parts of a compliance definition may already be proved or that the constraints of separate regulatory domains have some subexpressions in common.  In these case, inference over the constraints can lead to significant reduction in the complexity of the constraints to be proved.  For this reason, we choose to address a constraint language that meets our broader objectives:
\begin{enumerate}
    \item Ability to break constraints into subconstraints that are easily described in natural language for easy human-level understandability
    \item Relative easy of checking for logical implication between constraints\footnote{``Relative'' because, while the satisfiability problem is NP-complete, proving that code in a Turing-complete language generates a particular result is undecidable.}
    \item Suitability to be compiled into a ZK DSL for proof generation.
\end{enumerate}

\subsubsection{Constraint benefits: previously proved constraints}

Similar to the benefit of multiple compliance definitions sharing constraints, a previously proved constraint does not need to be recomputed if it references a static blockchain state and has the same parameters.

Additionally, a constraint over a user's entire transaction history only has to compute the transactions since the constraint was last validated.

\reminder{Joss: Is it a significant optimization when constraints have overlapping domain inputs?  Ex: constraints over the same }

\subsection{Proof history}
\reminder{Joss: Not exactly sure what to call this section but it's an important point / optimization that number of blocks since last proof isn't a factor in proof generation time}
On first proof generation of an address, the beginning time T0 will be the transaction when the addresses first received funds and the ending time T1 will be the last transaction that interacted with the address.  When the address wishes to generate another proof of the same program, T0 will be the last time the address successfully verified a proof of this program and T1 will be the last transaction that interacted with the address.

Number of transactions from the address being proven for is the driving cost of proving time, not number of blocks since last proof generation.  A user with 1 transaction who last verified a proof 1000 blocks ago will have the same proving time as a user with 1 transaction who last verified a proof 5 blocks ago.  The ZK proof will take the address' transactions as inputs and verify the compliance constraints against each transaction.  The user can then use that proof to interact with an on-chain contract who requires compliance proof validation.

\reminder{HFK: Other factors include how constraints are structured. Constraints whose proofs can employ folding or recursion are able to reuse prior proofs to advantage in their proofs.  There is probably a lot that could be written about constraint design for efficient operation.}

\subsection{Alternate applications of constraint proving}
This paper was mostly focused on the use case of proving compliance over a transaction history.  However the underlying mechanism of proving arbitrary properties of a transaction history can be used in other scenarios.  It could potentially even move some smart contract execution off-chain by requiring a proof that an invariant holds for a particular address instead of calculating it on-chain.

\bibliographystyle{abbrv}
\bibliography{blockchain}
\end{document}

